###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.11.1.50453 for Atmel AVR        18/Dec/2014  15:36:25 #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\1307B\Work5\main.c                                    #
#    Command line =  D:\1307B\Work5\main.c --cpu=m16 -ms -o                   #
#                    D:\1307B\Work5\Debug\Obj\ -lC                            #
#                    D:\1307B\Work5\Debug\List\ -lA                           #
#                    D:\1307B\Work5\Debug\List\ --initializers_in_flash       #
#                    --no_cse --no_inline --no_code_motion --no_cross_call    #
#                    --no_clustering --no_tbaa --debug                        #
#                    -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -On #
#    List file    =  D:\1307B\Work5\Debug\List\main.lst                       #
#    Object file  =  D:\1307B\Work5\Debug\Obj\main.r90                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\1307B\Work5\main.c
      1          #define CRC16_CCITT 0x1021 
      2          #include "usart.h"

   \                                 In  segment ABSOLUTE, at 0x2c
   \   union <unnamed> volatile __io _A_UDR
   \                     _A_UDR:
   \   00000000                      DS8 1
      3          

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
      4          unsigned int ch=0xffff;
   \                     ch:
   \   00000000                      DS8 2
   \   00000002                      REQUIRE `?<Initializer for ch>`

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
      5          unsigned char character='0';
   \                     character:
   \   00000000                      DS8 1
   \   00000001                      REQUIRE `?<Initializer for character>`

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      6          unsigned char  vect[20]={'\0'};
   \                     vect:
   \   00000000                      DS8 20

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      7          int indexVec=0;
   \                     indexVec:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      8          int number=0;
   \                     number:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
      9          int index=3;
   \                     index:
   \   00000000                      DS8 2
   \   00000002                      REQUIRE `?<Initializer for index>`

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     10          int flag=0;
   \                     flag:
   \   00000000                      DS8 2
     11          
     12          #pragma vector = USART_RXC_vect
     13          /*__interrupt void interrupt_routine_USART_RXC(void)
     14          {
     15          character=UDR;
     16          number++;
     17          if(number>2)
     18          {
     19          ch&=(ch>>(index*4))&character; 
     20          index--;
     21          
     22            }
     23          if(number==6)
     24          {
     25          flag=1; 
     26            }
     27          }*/
     28          
     29          #pragma vector = USART_RXC_vect

   \                                 In  segment CODE, align 2, keep-with-next
     30          __interrupt void interrupt_routine_USART_RXC(void)
                                  ^
Warning[Pa023]: more than one #pragma vector active for this declaration
   \                     interrupt_routine_USART_RXC:
     31          {
   \   00000000   93AA               ST      -Y, R26
   \   00000002   939A               ST      -Y, R25
   \   00000004   938A               ST      -Y, R24
   \   00000006   93FA               ST      -Y, R31
   \   00000008   93EA               ST      -Y, R30
   \   0000000A   923A               ST      -Y, R3
   \   0000000C   922A               ST      -Y, R2
   \   0000000E   921A               ST      -Y, R1
   \   00000010   920A               ST      -Y, R0
   \   00000012   937A               ST      -Y, R23
   \   00000014   936A               ST      -Y, R22
   \   00000016   935A               ST      -Y, R21
   \   00000018   934A               ST      -Y, R20
   \   0000001A   933A               ST      -Y, R19
   \   0000001C   932A               ST      -Y, R18
   \   0000001E   931A               ST      -Y, R17
   \   00000020   930A               ST      -Y, R16
   \   00000022   B7AF               IN      R26, 0x3F
     32            character=UDR;
   \   00000024   B10C               IN      R16, 0x0C
   \   00000026   9300....           STS     character, R16
     33            if(indexVec<14)
   \   0000002A   91E0....           LDS     R30, indexVec
   \   0000002E   91F0....           LDS     R31, (indexVec + 1)
   \   00000032   973E               SBIW    R31:R30, 14
   \   00000034   F49C               BRGE    ??interrupt_routine_USART_RXC_0
     34              vect[indexVec++]=character;
   \   00000036   9100....           LDS     R16, character
   \   0000003A   9120....           LDS     R18, indexVec
   \   0000003E   9130....           LDS     R19, (indexVec + 1)
   \   00000042   01F9               MOVW    R31:R30, R19:R18
   \   00000044   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000046   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000048   8300               ST      Z, R16
   \   0000004A   ....               LDI     R30, LOW(indexVec)
   \   0000004C   ....               LDI     R31, (indexVec) >> 8
   \   0000004E   8100               LD      R16, Z
   \   00000050   8111               LDD     R17, Z+1
   \   00000052   5F0F               SUBI    R16, 255
   \   00000054   4F1F               SBCI    R17, 255
   \   00000056   8300               ST      Z, R16
   \   00000058   8311               STD     Z+1, R17
   \   0000005A   C011               RJMP    ??interrupt_routine_USART_RXC_1
     35            else
     36            {
     37             for(int i=0;i<indexVec;++i)
   \                     ??interrupt_routine_USART_RXC_0:
   \   0000005C   E080               LDI     R24, 0
   \   0000005E   E090               LDI     R25, 0
   \                     ??interrupt_routine_USART_RXC_2:
   \   00000060   9100....           LDS     R16, indexVec
   \   00000064   9110....           LDS     R17, (indexVec + 1)
   \   00000068   1780               CP      R24, R16
   \   0000006A   0791               CPC     R25, R17
   \   0000006C   F444               BRGE    ??interrupt_routine_USART_RXC_1
     38             {
     39              USART_transmit(vect[i]); 
   \   0000006E   01FC               MOVW    R31:R30, R25:R24
   \   00000070   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000072   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000074   8100               LD      R16, Z
   \   00000076   ........           CALL    USART_transmit
     40             }
   \   0000007A   9601               ADIW    R25:R24, 1
   \   0000007C   CFF1               RJMP    ??interrupt_routine_USART_RXC_2
     41              
     42            }
     43            
     44          }
   \                     ??interrupt_routine_USART_RXC_1:
   \   0000007E   BFAF               OUT     0x3F, R26
   \   00000080   9109               LD      R16, Y+
   \   00000082   9119               LD      R17, Y+
   \   00000084   9129               LD      R18, Y+
   \   00000086   9139               LD      R19, Y+
   \   00000088   9149               LD      R20, Y+
   \   0000008A   9159               LD      R21, Y+
   \   0000008C   9169               LD      R22, Y+
   \   0000008E   9179               LD      R23, Y+
   \   00000090   9009               LD      R0, Y+
   \   00000092   9019               LD      R1, Y+
   \   00000094   9029               LD      R2, Y+
   \   00000096   9039               LD      R3, Y+
   \   00000098   91E9               LD      R30, Y+
   \   0000009A   91F9               LD      R31, Y+
   \   0000009C   9189               LD      R24, Y+
   \   0000009E   9199               LD      R25, Y+
   \   000000A0   91A9               LD      R26, Y+
   \   000000A2   9518               RETI
   \   000000A4                      REQUIRE _A_UDR
     45          
     46          enum BitOrder { LSBF, MSBF };
     47          

   \                                 In  segment CODE, align 2, keep-with-next
     48          unsigned int crc16(unsigned int polinom16, unsigned int init_val_16,unsigned int adr_start,unsigned int len, enum BitOrder ord)
   \                     crc16:
     49          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   0108               MOVW    R1:R0, R17:R16
   \   00000006   01FA               MOVW    R31:R30, R21:R20
   \   00000008   802C               LDD     R2, Y+4
     50            //rezultatul final
     51            unsigned int crc = init_val_16;
   \   0000000A   0189               MOVW    R17:R16, R19:R18
     52            //reþine în octetul cel mai semnificativ datele
     53            //extrase din memoria flash
     54            unsigned int data = 0;
   \   0000000C   E040               LDI     R20, 0
   \   0000000E   E050               LDI     R21, 0
     55            while( len-- ) {
   \                     ??crc16_0:
   \   00000010   01CB               MOVW    R25:R24, R23:R22
   \   00000012   01BC               MOVW    R23:R22, R25:R24
   \   00000014   5061               SUBI    R22, 1
   \   00000016   4070               SBCI    R23, 0
   \   00000018   2B89               OR      R24, R25
   \   0000001A   F181               BREQ    ??crc16_1
     56              unsigned int i;
     57              //se extrage valoarea unui octet de la adresa de start
     58              //din memoria flash
     59              data = *(__flash char *)adr_start;
   \   0000001C   9184               LPM     R24, Z
   \   0000001E   E090               LDI     R25, 0
   \   00000020   01AC               MOVW    R21:R20, R25:R24
     60              if ( ord == MSBF ) //opþiunea cu shiftare spre MSB
   \   00000022   E081               LDI     R24, 1
   \   00000024   1628               CP      R2, R24
   \   00000026   F4B1               BRNE    ??crc16_2
     61              {
     62                //octetul este shiftat la stânga pentru a se alinia
     63                //cu polinomul generator
     64                data <<= 8;
   \   00000028   2F54               MOV     R21, R20
   \   0000002A   E040               LDI     R20, 0
     65                //datele sunt "transferate" în rezultat
     66                crc ^= data;
   \   0000002C   2704               EOR     R16, R20
   \   0000002E   2715               EOR     R17, R21
     67                adr_start++;
   \   00000030   9631               ADIW    R31:R30, 1
     68                //pentru biþii de date se face XOR cu polinomul generator,
     69                //daca bitul cel mai semnificativ este 1 sau se shifteaza datele
     70                //la stânga, dacã bitul cel mai semnificativ este 0
     71                for( i = 0; i < 8; ++i ) {
   \   00000032   E0A0               LDI     R26, 0
   \   00000034   E0B0               LDI     R27, 0
   \                     ??crc16_3:
   \   00000036   30A8               CPI     R26, 8
   \   00000038   E080               LDI     R24, 0
   \   0000003A   07B8               CPC     R27, R24
   \   0000003C   F748               BRCC    ??crc16_0
     72                  //se verificã dacã bitul cel mai semnificativ este 1
     73                  if( crc & 0x8000 )
   \   0000003E   FB17               BST     R17, 7
   \   00000040   F42E               BRTC    ??crc16_4
     74                    crc = (crc << 1) ^ polinom16;
   \   00000042   0F00               LSL     R16
   \   00000044   1F11               ROL     R17
   \   00000046   2500               EOR     R16, R0
   \   00000048   2511               EOR     R17, R1
   \   0000004A   C002               RJMP    ??crc16_5
     75                  else
     76                    crc = crc << 1;
   \                     ??crc16_4:
   \   0000004C   0F00               LSL     R16
   \   0000004E   1F11               ROL     R17
     77                }
   \                     ??crc16_5:
   \   00000050   9611               ADIW    R27:R26, 1
   \   00000052   CFF1               RJMP    ??crc16_3
     78              }
     79              else
     80                //opþiunea cu shiftare spre LSB
     81                //parametrul polinom16 al funcþiei trebuie sã aibã biþii inversaþi în
     82                //prealabil
     83              {
     84                crc ^= data;
   \                     ??crc16_2:
   \   00000054   2704               EOR     R16, R20
   \   00000056   2715               EOR     R17, R21
     85                adr_start++;
   \   00000058   9631               ADIW    R31:R30, 1
     86                //se verificã bitul cel mai putin semnificativ .i dacã
     87                //acesta este 1 se face XOR cu polinomul generator,
     88                // altfel datele sunt shiftate la dreapta
     89                for( i = 0; i < 8; ++i ) {
   \   0000005A   E0A0               LDI     R26, 0
   \   0000005C   E0B0               LDI     R27, 0
   \                     ??crc16_6:
   \   0000005E   30A8               CPI     R26, 8
   \   00000060   E080               LDI     R24, 0
   \   00000062   07B8               CPC     R27, R24
   \   00000064   F6A8               BRCC    ??crc16_0
     90                  //se verificã daca cel mai puþin semnificativ bit este 1
     91                  if( crc & 0x0001 )
   \   00000066   FB00               BST     R16, 0
   \   00000068   F42E               BRTC    ??crc16_7
     92                    crc = (crc >> 1) ^ polinom16;
   \   0000006A   9516               LSR     R17
   \   0000006C   9507               ROR     R16
   \   0000006E   2500               EOR     R16, R0
   \   00000070   2511               EOR     R17, R1
   \   00000072   C002               RJMP    ??crc16_8
     93                  else
     94                    crc = crc >> 1;
   \                     ??crc16_7:
   \   00000074   9516               LSR     R17
   \   00000076   9507               ROR     R16
     95                }
   \                     ??crc16_8:
   \   00000078   9611               ADIW    R27:R26, 1
   \   0000007A   CFF1               RJMP    ??crc16_6
     96              }
     97            }
     98            return crc;
   \                     ??crc16_1:
   \   0000007C   E0E5               LDI     R30, 5
   \   0000007E   ........           JMP     ?EPILOGUE_B4_L09
     99          }
    100          
    101          
    102          //aceasta implementare utilizeazã o tabelã cu valori pre-calculate ale //funcþiei CRC16

   \                                 In  segment NEAR_F, align 1, keep-with-next
    103          __flash const unsigned int crc16tab[256]= { 0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7, 0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef, 0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6, 0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de, 0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485, 0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d, 0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4, 0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc, 0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823, 0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b, 0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12, 0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a, 0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41, 0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49, 0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70, 0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78, 0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f, 0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067, 0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e, 0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256, 0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d, 0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405, 0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c, 0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634, 0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab, 0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3, 0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a, 0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92, 0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9, 0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1, 0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8, 0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0 };
   \                     crc16tab:
   \   00000000   000010212042       DC16 0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161
   \              3063408450A5
   \              60C670E78108
   \              9129        
   \   00000014   A14AB16BC18C       DC16 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786
   \              D1ADE1CEF1EF
   \              123102103273
   \              2252        
   \   00000028   52B5429472F7       DC16 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205
   \              62D693398318
   \              B37BA35AD3BD
   \   0000003A   C39CF3FFE3DE       DC16 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572
   \              246234430420
   \              140164E674C7
   \              44A4        
   \   0000004E   5485A56AB54B       DC16 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669
   \              85289509E5EE
   \              F5CFC5ACD58D
   \   00000060   365326721611       DC16 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874
   \              063076D766F6
   \              569546B4B75B
   \              A77A        
   \   00000074   97198738F7DF       DC16 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758
   \              E7FED79DC7BC
   \              48C458E56886
   \   00000086   78A708401861       DC16 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144
   \              28023823C9CC
   \              D9EDE98EF9AF
   \              8948        
   \   0000009A   9969A90AB92B       DC16 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899
   \              5AF54AD47AB7
   \              6A961A710A50
   \              3A33        
   \   000000AE   2A12DBFDCBDC       DC16 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802
   \              FBBFEB9E9B79
   \              8B58BB3BAB1A
   \   000000C0   6CA67C874CE4       DC16 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911
   \              5CC52C223C03
   \              0C601C41EDAE
   \              FD8F        
   \   000000D4   CDECDDCDAD2A       DC16 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277
   \              BD0B8D689D49
   \              7E976EB65ED5
   \   000000E6   4EF43E132E32       DC16 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923
   \              1E510E70FF9F
   \              EFBEDFDDCFFC
   \              BF1B        
   \   000000FA   AF3A9F598F78       DC16 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453
   \              918881A9B1CA
   \              A1EBD10CC12D
   \   0000010C   F14EE16F1080       DC16 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679
   \              00A130C220E3
   \              500440257046
   \              6067        
   \   00000120   83B99398A3FB       DC16 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752
   \              B3DAC33DD31C
   \              E37FF35E02B1
   \              1290        
   \   00000134   22F332D24235       DC16 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312
   \              521462777256
   \              B5EAA5CB95A8
   \   00000146   8589F56EE54F       DC16 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798
   \              D52CC50D34E2
   \              24C314A00481
   \              7466        
   \   0000015A   644754244405       DC16 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358
   \              A7DBB7FA8799
   \              97B8E75FF77E
   \   0000016C   C71DD73C26D3       DC16 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068
   \              36F2069116B0
   \              665776764615
   \              5634        
   \   00000180   D94CC96DF90E       DC16 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596
   \              E92F99C889E9
   \              B98AA9AB5844
   \   00000192   486578066827       DC16 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223
   \              18C008E13882
   \              28A3CB7DDB5C
   \              EB3F        
   \   000001A6   FB1E8BF99BD8       DC16 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254
   \              ABBBBB9A4A75
   \              5A546A377A16
   \   000001B8   0AF11AD02AB3       DC16 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427
   \              3A92FD2EED0F
   \              DD6CCD4DBDAA
   \              AD8B        
   \   000001CC   9DE88DC97C26       DC16 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265
   \              6C075C644C45
   \              3CA22C831CE0
   \              0CC1        
   \   000001E0   EF1FFF3ECF5D       DC16 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183
   \              DF7CAF9BBFBA
   \              8FD99FF86E17
   \   000001F2   7E364E555E74       DC16 32310, 20053, 24180, 11923, 16050, 3793, 7920
   \              2E933EB20ED1
   \              1EF0        

   \                                 In  segment CODE, align 2, keep-with-next
    104          unsigned int crc16wtable(unsigned int init_val_16,unsigned int adr_start, unsigned int len) { unsigned int counter; unsigned int crc = init_val_16; for( counter = 0; counter < len; counter++) crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *(__flash char *)adr_start++) & 0x00FF]; return crc; }
   \                     crc16wtable:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   0108               MOVW    R1:R0, R17:R16
   \   00000006   0180               MOVW    R17:R16, R1:R0
   \   00000008   E080               LDI     R24, 0
   \   0000000A   E090               LDI     R25, 0
   \                     ??crc16wtable_0:
   \   0000000C   1784               CP      R24, R20
   \   0000000E   0795               CPC     R25, R21
   \   00000010   F4C8               BRCC    ??crc16wtable_1
   \   00000012   0118               MOVW    R3:R2, R17:R16
   \   00000014   2C32               MOV     R3, R2
   \   00000016   2422               CLR     R2
   \   00000018   2F01               MOV     R16, R17
   \   0000001A   E010               LDI     R17, 0
   \   0000001C   01F9               MOVW    R31:R30, R19:R18
   \   0000001E   9164               LPM     R22, Z
   \   00000020   E070               LDI     R23, 0
   \   00000022   2706               EOR     R16, R22
   \   00000024   2717               EOR     R17, R23
   \   00000026   0F00               LSL     R16
   \   00000028   1F11               ROL     R17
   \   0000002A   01F8               MOVW    R31:R30, R17:R16
   \   0000002C   ....               SUBI    R30, LOW((-(crc16tab) & 0xFFFF))
   \   0000002E   ....               SBCI    R31, (-(crc16tab) & 0xFFFF) >> 8
   \   00000030   9165               LPM     R22, Z+
   \   00000032   9174               LPM     R23, Z
   \   00000034   9731               SBIW    R31:R30, 1
   \   00000036   0181               MOVW    R17:R16, R3:R2
   \   00000038   2706               EOR     R16, R22
   \   0000003A   2717               EOR     R17, R23
   \   0000003C   5F2F               SUBI    R18, 255
   \   0000003E   4F3F               SBCI    R19, 255
   \   00000040   9601               ADIW    R25:R24, 1
   \   00000042   CFE4               RJMP    ??crc16wtable_0
   \                     ??crc16wtable_1:
   \   00000044   9189               LD      R24, Y+
   \   00000046   9199               LD      R25, Y+
   \   00000048   9508               RET
    105          
    106          

   \                                 In  segment CODE, align 2, keep-with-next
    107          void readAdr(unsigned int *adr)
   \                     readAdr:
    108          {
    109            
    110            
    111            
    112          }
   \   00000000   9508               RET
    113          

   \                                 In  segment CODE, align 2, keep-with-next
    114          unsigned int chToHex(unsigned char c)
   \                     chToHex:
    115          {
   \   00000000   2F39               MOV     R19, R25
   \   00000002   2F48               MOV     R20, R24
   \   00000004   2FE0               MOV     R30, R16
    116            unsigned int rez=0;
   \   00000006   E000               LDI     R16, 0
   \   00000008   E010               LDI     R17, 0
    117            if(c<='9')
   \   0000000A   33EA               CPI     R30, 58
   \   0000000C   F428               BRCC    ??chToHex_0
    118            {
    119              rez = c-'0';
   \   0000000E   2F8E               MOV     R24, R30
   \   00000010   E090               LDI     R25, 0
   \   00000012   97C0               SBIW    R25:R24, 48
   \   00000014   018C               MOVW    R17:R16, R25:R24
   \   00000016   C004               RJMP    ??chToHex_1
    120            }
    121            else
    122            {
    123              rez = c-'A'+10;
   \                     ??chToHex_0:
   \   00000018   2F8E               MOV     R24, R30
   \   0000001A   E090               LDI     R25, 0
   \   0000001C   97C7               SBIW    R25:R24, 55
   \   0000001E   018C               MOVW    R17:R16, R25:R24
    124            }
    125            
    126            return rez;  
   \                     ??chToHex_1:
   \   00000020   2F84               MOV     R24, R20
   \   00000022   2F93               MOV     R25, R19
   \   00000024   9508               RET
    127          }
    128          
    129          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    130          unsigned long real_crc;
   \                     real_crc:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    131          unsigned int my_crc16;
   \                     my_crc16:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    132          unsigned long  my_crc16_t;
   \                     my_crc16_t:
   \   00000000                      DS8 4

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    133          unsigned int adresaFinal=0x0000;
   \                     adresaFinal:
   \   00000000                      DS8 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    134          unsigned int adresaInceput=0x0000;
   \                     adresaInceput:
   \   00000000                      DS8 2

   \                                 In  segment CODE, align 2, keep-with-next
    135          void main()
   \                     main:
    136          {
   \   00000000   ........           CALL    ?PROLOGUE12_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004                      REQUIRE ?Register_R11_is_cg_reg
    137            int num=1;
   \   00000004   2499               CLR     R9
   \   00000006   2488               CLR     R8
   \   00000008   9483               INC     R8
    138            int i=0;
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
    139            int ind=0;
   \   0000000E   24AA               CLR     R10
   \   00000010   24BB               CLR     R11
    140            unsigned int nr=0x0000;
   \   00000012   E0A0               LDI     R26, 0
   \   00000014   E0B0               LDI     R27, 0
    141            
    142            
    143            __enable_interrupt();
   \   00000016   9478               SEI
    144            USART_initialize(BAUD_RATE);
   \   00000018   E00C               LDI     R16, 12
   \   0000001A   E010               LDI     R17, 0
   \   0000001C   ........           CALL    USART_initialize
    145            
    146           
    147            
    148            while(1)
    149            {
    150              
    151               if(indexVec==13)
   \                     ??main_0:
   \   00000020   9100....           LDS     R16, indexVec
   \   00000024   9110....           LDS     R17, (indexVec + 1)
   \   00000028   300D               CPI     R16, 13
   \   0000002A   E020               LDI     R18, 0
   \   0000002C   0712               CPC     R17, R18
   \   0000002E   F7C1               BRNE    ??main_0
    152            {
    153              while(i<20)
   \                     ??main_1:
   \   00000030   3184               CPI     R24, 20
   \   00000032   E000               LDI     R16, 0
   \   00000034   0790               CPC     R25, R16
   \   00000036   F00C               BRLT    $+2+2
   \   00000038   C08B               RJMP    ??main_2
    154            {
    155              if(vect[i]=='0' && vect[i+1]=='x' && (i+1)<20)
   \   0000003A   01FC               MOVW    R31:R30, R25:R24
   \   0000003C   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   0000003E   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000040   8100               LD      R16, Z
   \   00000042   3300               CPI     R16, 48
   \   00000044   F009               BREQ    $+2+2
   \   00000046   C082               RJMP    ??main_3
   \   00000048   01FC               MOVW    R31:R30, R25:R24
   \   0000004A   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   0000004C   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   0000004E   8101               LDD     R16, Z+1
   \   00000050   3708               CPI     R16, 120
   \   00000052   F009               BREQ    $+2+2
   \   00000054   C07B               RJMP    ??main_3
   \   00000056   01FC               MOVW    R31:R30, R25:R24
   \   00000058   9631               ADIW    R31:R30, 1
   \   0000005A   9774               SBIW    R31:R30, 20
   \   0000005C   F00C               BRLT    $+2+2
   \   0000005E   C076               RJMP    ??main_3
    156              {
    157                i+=2; 
   \   00000060   9602               ADIW    R25:R24, 2
    158                if(num==1)
   \   00000062   E001               LDI     R16, 1
   \   00000064   1680               CP      R8, R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   0690               CPC     R9, R16
   \   0000006A   F5B9               BRNE    ??main_4
    159                {
    160                  nr=chToHex(vect[i]);
   \   0000006C   01FC               MOVW    R31:R30, R25:R24
   \   0000006E   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000070   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000072   8100               LD      R16, Z
   \   00000074   ....               RCALL   chToHex
   \   00000076   01D8               MOVW    R27:R26, R17:R16
    161                  nr=(nr<<4)+chToHex(vect[i+1]);
   \   00000078   E044               LDI     R20, 4
   \   0000007A   018D               MOVW    R17:R16, R27:R26
   \   0000007C   ........           CALL    ?S_SHL_L02
   \   00000080   0128               MOVW    R5:R4, R17:R16
   \   00000082   01FC               MOVW    R31:R30, R25:R24
   \   00000084   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000086   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000088   8101               LDD     R16, Z+1
   \   0000008A   ....               RCALL   chToHex
   \   0000008C   0E40               ADD     R4, R16
   \   0000008E   1E51               ADC     R5, R17
   \   00000090   01D2               MOVW    R27:R26, R5:R4
    162                  nr=(nr<<4)+chToHex(vect[i+2]);
   \   00000092   E044               LDI     R20, 4
   \   00000094   018D               MOVW    R17:R16, R27:R26
   \   00000096   ........           CALL    ?S_SHL_L02
   \   0000009A   0128               MOVW    R5:R4, R17:R16
   \   0000009C   01FC               MOVW    R31:R30, R25:R24
   \   0000009E   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   000000A0   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   000000A2   8102               LDD     R16, Z+2
   \   000000A4   ....               RCALL   chToHex
   \   000000A6   0E40               ADD     R4, R16
   \   000000A8   1E51               ADC     R5, R17
   \   000000AA   01D2               MOVW    R27:R26, R5:R4
    163                  nr=(nr<<4)+chToHex(vect[i+3]);
   \   000000AC   E044               LDI     R20, 4
   \   000000AE   018D               MOVW    R17:R16, R27:R26
   \   000000B0   ........           CALL    ?S_SHL_L02
   \   000000B4   0128               MOVW    R5:R4, R17:R16
   \   000000B6   01FC               MOVW    R31:R30, R25:R24
   \   000000B8   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   000000BA   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   000000BC   8103               LDD     R16, Z+3
   \   000000BE   ....               RCALL   chToHex
   \   000000C0   0E40               ADD     R4, R16
   \   000000C2   1E51               ADC     R5, R17
   \   000000C4   01D2               MOVW    R27:R26, R5:R4
    164                  adresaInceput=nr;
   \   000000C6   93A0....           STS     adresaInceput, R26
   \   000000CA   93B0....           STS     (adresaInceput + 1), R27
    165                  num=2;
   \   000000CE   E002               LDI     R16, 2
   \   000000D0   2E80               MOV     R8, R16
   \   000000D2   2499               CLR     R9
    166                  nr=0x0000;
   \   000000D4   E0A0               LDI     R26, 0
   \   000000D6   E0B0               LDI     R27, 0
   \   000000D8   C039               RJMP    ??main_3
    167                  
    168            
    169                }
    170                else
    171                {
    172                  if(num==2)
   \                     ??main_4:
   \   000000DA   E002               LDI     R16, 2
   \   000000DC   1680               CP      R8, R16
   \   000000DE   E000               LDI     R16, 0
   \   000000E0   0690               CPC     R9, R16
   \   000000E2   F5B1               BRNE    ??main_2
    173                  {
    174                  nr=chToHex(vect[i]);
   \   000000E4   01FC               MOVW    R31:R30, R25:R24
   \   000000E6   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   000000E8   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   000000EA   8100               LD      R16, Z
   \   000000EC   ....               RCALL   chToHex
   \   000000EE   01D8               MOVW    R27:R26, R17:R16
    175                  nr=(nr<<4)+chToHex(vect[i+1]);
   \   000000F0   E044               LDI     R20, 4
   \   000000F2   018D               MOVW    R17:R16, R27:R26
   \   000000F4   ........           CALL    ?S_SHL_L02
   \   000000F8   0128               MOVW    R5:R4, R17:R16
   \   000000FA   01FC               MOVW    R31:R30, R25:R24
   \   000000FC   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   000000FE   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000100   8101               LDD     R16, Z+1
   \   00000102   ....               RCALL   chToHex
   \   00000104   0E40               ADD     R4, R16
   \   00000106   1E51               ADC     R5, R17
   \   00000108   01D2               MOVW    R27:R26, R5:R4
    176                  nr=(nr<<4)+chToHex(vect[i+2]);
   \   0000010A   E044               LDI     R20, 4
   \   0000010C   018D               MOVW    R17:R16, R27:R26
   \   0000010E   ........           CALL    ?S_SHL_L02
   \   00000112   0128               MOVW    R5:R4, R17:R16
   \   00000114   01FC               MOVW    R31:R30, R25:R24
   \   00000116   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000118   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   0000011A   8102               LDD     R16, Z+2
   \   0000011C   ....               RCALL   chToHex
   \   0000011E   0E40               ADD     R4, R16
   \   00000120   1E51               ADC     R5, R17
   \   00000122   01D2               MOVW    R27:R26, R5:R4
    177                  nr=(nr<<4)+chToHex(vect[i+3]);
   \   00000124   E044               LDI     R20, 4
   \   00000126   018D               MOVW    R17:R16, R27:R26
   \   00000128   ........           CALL    ?S_SHL_L02
   \   0000012C   0128               MOVW    R5:R4, R17:R16
   \   0000012E   01FC               MOVW    R31:R30, R25:R24
   \   00000130   ....               SUBI    R30, LOW((-(vect) & 0xFFFF))
   \   00000132   ....               SBCI    R31, (-(vect) & 0xFFFF) >> 8
   \   00000134   8103               LDD     R16, Z+3
   \   00000136   ....               RCALL   chToHex
   \   00000138   0E40               ADD     R4, R16
   \   0000013A   1E51               ADC     R5, R17
   \   0000013C   01D2               MOVW    R27:R26, R5:R4
    178                  adresaFinal=nr;
   \   0000013E   93A0....           STS     adresaFinal, R26
   \   00000142   93B0....           STS     (adresaFinal + 1), R27
    179                  num=3;  
   \   00000146   E003               LDI     R16, 3
   \   00000148   2E80               MOV     R8, R16
   \   0000014A   2499               CLR     R9
    180                  }
    181                  else
    182                  {
    183                    break;
    184                  }
    185                  
    186                }
    187                 
    188              }
    189              i++;
   \                     ??main_3:
   \   0000014C   9601               ADIW    R25:R24, 1
   \   0000014E   CF70               RJMP    ??main_1
    190           
    191            }
    192            
    193            if(adresaInceput!=0x0000 && adresaFinal!=0x0000)
   \                     ??main_2:
   \   00000150   9100....           LDS     R16, adresaInceput
   \   00000154   9110....           LDS     R17, (adresaInceput + 1)
   \   00000158   2B01               OR      R16, R17
   \   0000015A   F409               BRNE    $+2+2
   \   0000015C   CF61               RJMP    ??main_0
   \   0000015E   9100....           LDS     R16, adresaFinal
   \   00000162   9110....           LDS     R17, (adresaFinal + 1)
   \   00000166   2B01               OR      R16, R17
   \   00000168   F409               BRNE    $+2+2
   \   0000016A   CF5A               RJMP    ??main_0
    194            {
    195            unsigned int adrInceput = (unsigned int)*(__flash unsigned int*)(adresaInceput);
   \   0000016C   91E0....           LDS     R30, adresaInceput
   \   00000170   91F0....           LDS     R31, (adresaInceput + 1)
   \   00000174   9045               LPM     R4, Z+
   \   00000176   9054               LPM     R5, Z
   \   00000178   9731               SBIW    R31:R30, 1
    196            unsigned int adrFinal = (unsigned int)*(__flash unsigned int*)(adresaFinal);
                                ^
Warning[Pe177]: variable "adrFinal" was declared but never referenced

    int ind=0;
        ^
"D:\1307B\Work5\main.c",139  Warning[Pe177]: variable "ind" was declared but
          never referenced
   \   0000017A   91E0....           LDS     R30, adresaFinal
   \   0000017E   91F0....           LDS     R31, (adresaFinal + 1)
   \   00000182   9065               LPM     R6, Z+
   \   00000184   9074               LPM     R7, Z
   \   00000186   9731               SBIW    R31:R30, 1
    197            my_crc16=crc16(CRC16_CCITT,0,adrInceput,adresaFinal-adresaInceput,MSBF);
   \   00000188   E001               LDI     R16, 1
   \   0000018A   930A               ST      -Y, R16
   \   0000018C   9160....           LDS     R22, adresaFinal
   \   00000190   9170....           LDS     R23, (adresaFinal + 1)
   \   00000194   9100....           LDS     R16, adresaInceput
   \   00000198   9110....           LDS     R17, (adresaInceput + 1)
   \   0000019C   1B60               SUB     R22, R16
   \   0000019E   0B71               SBC     R23, R17
   \   000001A0   01A2               MOVW    R21:R20, R5:R4
   \   000001A2   E020               LDI     R18, 0
   \   000001A4   E030               LDI     R19, 0
   \   000001A6   E201               LDI     R16, 33
   \   000001A8   E110               LDI     R17, 16
   \   000001AA   ....               RCALL   crc16
   \   000001AC   9300....           STS     my_crc16, R16
   \   000001B0   9310....           STS     (my_crc16 + 1), R17
    198            my_crc16_t=crc16wtable(0,adrInceput,adresaFinal-adresaInceput);
   \   000001B4   9140....           LDS     R20, adresaFinal
   \   000001B8   9150....           LDS     R21, (adresaFinal + 1)
   \   000001BC   9100....           LDS     R16, adresaInceput
   \   000001C0   9110....           LDS     R17, (adresaInceput + 1)
   \   000001C4   1B40               SUB     R20, R16
   \   000001C6   0B51               SBC     R21, R17
   \   000001C8   0192               MOVW    R19:R18, R5:R4
   \   000001CA   E000               LDI     R16, 0
   \   000001CC   E010               LDI     R17, 0
   \   000001CE   ....               RCALL   crc16wtable
   \   000001D0   E020               LDI     R18, 0
   \   000001D2   E030               LDI     R19, 0
   \   000001D4   ....               LDI     R30, LOW(my_crc16_t)
   \   000001D6   ....               LDI     R31, (my_crc16_t) >> 8
   \   000001D8   8300               ST      Z, R16
   \   000001DA   8311               STD     Z+1, R17
   \   000001DC   8322               STD     Z+2, R18
   \   000001DE   8333               STD     Z+3, R19
   \   000001E0   CF1F               RJMP    ??main_0
    199              
    200            }
    201              
    202            }
    203            
    204            
    205            
    206              
    207            }
    208            
    209          }

   \                                 In  segment INTVEC, offset 0x2c, root
   \                     `??interrupt_routine_USART_RXC??INTVEC 44`:
   \   0000002C   ........           JMP     interrupt_routine_USART_RXC

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for ch>`:
   \   00000000   FFFF               DC16 65535

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for character>`:
   \   00000000   30                 DC8 48

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for index>`:
   \   00000000   0003               DC16 3

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       0      2  chToHex
       5      2  crc16
       2      2  crc16wtable
      17      2  interrupt_routine_USART_RXC
                   17 2 -> USART_transmit
      13      4  main
                   12 2 -> USART_initialize
                   12 2 -> chToHex
                   13 2 -> crc16
                   12 2 -> crc16wtable
       0      2  readAdr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for ch>
       1  ?<Initializer for character>
       2  ?<Initializer for index>
       4  ??interrupt_routine_USART_RXC??INTVEC 44
       1  _A_UDR
       2  adresaFinal
       2  adresaInceput
       2  ch
      38  chToHex
       1  character
     130  crc16
     512  crc16tab
      74  crc16wtable
       2  flag
       2  index
       2  indexVec
     164  interrupt_routine_USART_RXC
     482  main
       2  my_crc16
       4  my_crc16_t
       2  number
       2  readAdr
       4  real_crc
      20  vect
      12  -- Other

 
   1 byte  in segment ABSOLUTE
 890 bytes in segment CODE
  12 bytes in segment INITTAB
   4 bytes in segment INTVEC
 512 bytes in segment NEAR_F
   5 bytes in segment NEAR_I
   5 bytes in segment NEAR_ID
  40 bytes in segment NEAR_Z
 
 1 407 bytes of CODE memory (+ 16 bytes shared)
    45 bytes of DATA memory (+  1 byte  shared)

Errors: none
Warnings: 3
